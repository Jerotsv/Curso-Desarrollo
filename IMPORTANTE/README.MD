# INFORMACI√ìN IMPORTANTE PARA EL CURSO

## LIVE SERVER

Se puede crear desde el plugin o desde lista de comandos (Tiene que estar instalado, para comprobarlo hacer live-server -v en cmd)
Si queremos iniciar desde plugin debemos abrir repositorio de la carpeta especifica
Si por el contrario queremos abrirlo desde nuestras carpetas generales, debemos ir a la carpeta especifica y ejecutar el comando live-server

## INICIAR PROYECTO

Crear carpeta
Iniciar git init en la carpeta
Add .gitignore desde plugin o comando
Crear el readme.md con la informaci√≥n importante
npm init -y (Crea el archivo package.json)
Crear el .editorconfig acorde con el resto del grupo de trabajo
Hacer git add . para poder comitear el Initial commit
Hacer el primer commit "Initial commit"
Hacer remoto en GitHub
Hacer el push al remoto
Debemos tener estos 4 ficheros: readme.md, .gitignore, .package.json y .editorconfig

---

Una vez tengamos esto debemos crear el fichero INDEX.HTML, que debe estar en la carpeta ra√≠z para poder usar GitHub como hosting

### Configuracion b√°sica de tu package.json incluyendo node y ts

{
"name": "16.prisma",
"version": "1.0.0",
"main": "index.js",
"type": "module",
"scripts": {
"start": "cross-env NODE_ENV=prod node dist/index.js",
"start:dev": "cross-env NODE_ENV=dev DEBUG=films\* node --watch --env-file=.env ./dist/index.js",
"build": "tsc -w",
"lint": "eslint . --ext .ts"
},
"keywords": [],
"author": "",
"license": "ISC",
"description": "",
"prettier": {
"singleQuote": true
},
"devDependencies": {
"@eslint/js": "^9.21.0",
"@types/node": "^22.13.5",
"eslint": "^9.21.0",
"globals": "^16.0.0",
"prettier": "^3.5.2",
"typescript": "^5.7.3",
"typescript-eslint": "^8.25.0"
},
"dependencies": {
"cross-env": "^7.0.3"
}
}

## PREGUNTAS EXAMEN MODULO 1

-   Que significa HTML: Lenguaje de marcas de hipertexto (Hypertext Markup Language)
-   Que es root: Una pseudoclase
-   A que hace referencia root: A la etiqueta HTML y se usa por que tiene mayor
-   Que es el DOM (Document Object Model): El DOM es la conexi√≥n entre el navegador y el c√≥digo JavaScript, y te permite modificar la p√°gina web en tiempo real para crear experiencias interactivas y din√°micas.

## GESTI√ìN DE DATOS

-   Create
-   Read
-   Update
-   Delete

## PREGUNTAS EXAMEN MODULO 2

-   Lo que hay a la derecha del = SIEMPRE es una expresi√≥n
-   Una variable es un identificador asociado/asignado a un valor. Los identificadores los pintamos cuadrados y los valores en circulo.
-   MUY IMPORTANTE: 4 pilares de la programaci√≥n orientada a objetos (OOP): Abstracci√≥n, Encapsulaci√≥n, Herencia, Polimorfismo. **(LINEA 168 DE JS.PRO/DEMO-TS/INFO-TS/INFO.OOP.MD)**

    1. Abstracci√≥n: Consiste en simplificar la complejidad, mostrando solo las caracter√≠sticas esenciales de un objeto y ocultando las detalles innecesarios. Ayuda a centrarse en lo que hace un objeto sin preocuparse por c√≥mo lo hace

    2. Encapsulaci√≥n: Es el proceso de ocultar los detalles internos de un objeto y exponer solo la interfaz necesaria para interactuar con √©l. As√≠, puedes modificar el comportamiento interno de una clase sin afectar a otros componentes del sistema.

    3. Herencia: La herencia permite crear nuevas clases ((subclase o clase derivada)) basadas en clases existentes (superclase o clase base). Se puede decir que una clase "**hija**" hereda propiedades y m√©todos de una clase "**padre**". Esto permite la **reutilizaci√≥n** de c√≥digo y la **extensi√≥n** de funcionalidades, En TypeScript, se utiliza la palabra clave `extends` para indicar que una clase hereda de otra.

    4. Polimorfismo: Permite que diferentes clases respondan al mismo mensaje (m√©todo) de diferentes maneras. Esto facilita la extensi√≥n de las funcionalidades de una clase sin necesidad de modificar el c√≥digo existente

-   MUY IMPORTANTE PARA EL USO DE LA HERENCIA:
    La herencia debe usarse con cuidado para evitar dise√±os incorrectos o innecesariamente complicados. Algunas directrices importantes son:

1. **Evitar la herencia para reutilizaci√≥n de c√≥digo gen√©rico**: Si solo necesitas reutilizar c√≥digo, considera utilizar **composici√≥n** o **delegaci√≥n** en lugar de herencia.

2. **Dise√±o basado en relaciones "es-un"**: Utiliza herencia solo cuando exista una relaci√≥n natural de "es-un" entre las clases. Ejemplo: Un `Dog` es un `Animal`.

3. **Evitar herencias profundas**: Las jerarqu√≠as de herencia muy profundas pueden volverse dif√≠ciles de mantener. Prefiere herencias simples o jer√°rquicas limitadas.

4. **Usar clases abstractas para comportamiento com√∫n**: Las clases abstractas pueden ser √∫tiles para definir comportamientos comunes que deben ser implementados por las subclases.

5. **Prefiere la composici√≥n sobre la herencia**: Este es un principio de dise√±o com√∫n (conocido como "favor composition over inheritance"). La composici√≥n permite crear relaciones "tiene-un" en lugar de "es-un" y es m√°s flexible para cambios en el dise√±o.

Diferencias entre tipado de tuple y array:

-   const array = string[] (Tipado de array vacio de tipo string)
-   const tuple = [string, number, 'hola'] (Tipado dentro del array, se denomina tupla)

Que es y como nos protegemos de una inyeccion de sql?

-   Pasarle los datos mediante el placeholder ?,

APP.USE quiere decir, registra el middleware, usa este middleware. REGISTRA UNA FUNCI√ìN QUE SE VA A EJECUTAR CADA VEZ QUE RECIBA UNA REQUEST

Orden de ejecuci√≥n y responsabilidad de cada capa
Cuando un usuario hace una petici√≥n a tu API, el flujo suele seguir este orden:

1Ô∏è‚É£ server.ts (o .js)

Es el punto de entrada principal.
Arranca el servidor y enlaza la aplicaci√≥n con Express.
Escucha las peticiones en un puerto.

2Ô∏è‚É£ app.ts (o .js)

Inicializa Express y configura los middlewares globales.
Importa los routers para definir las rutas disponibles.
Se lo pasa al servidor para que comience a escuchar.

3Ô∏è‚É£ router/

Define las rutas de la API.
Llama al controller correspondiente cuando llega una petici√≥n.

4Ô∏è‚É£ middleware/

Son funciones intermedias que se ejecutan antes de llegar al controlador.
Ejemplos: validaci√≥n de datos, autenticaci√≥n, logging, manejo de errores.
Se pueden ejecutar a nivel global o por ruta espec√≠fica.

5Ô∏è‚É£ controller/

Se encarga de manejar la l√≥gica de cada endpoint.
Recibe la petici√≥n del router, extrae los datos, y llama al service o repository.
Retorna la respuesta adecuada.

6Ô∏è‚É£ services/

Contiene la l√≥gica de negocio de la aplicaci√≥n.
Se comunica con los repositories si es necesario acceder a la base de datos.
Realiza c√°lculos o transformaci√≥n de datos antes de enviarlos al controller.

7Ô∏è‚É£ repository/

Es la capa encargada de interactuar con la base de datos.
Encapsula la l√≥gica de acceso a los datos.
Solo se comunica con la capa de services.

8Ô∏è‚É£ types/

Define interfaces y tipos para TypeScript.
Se usa para estructurar los datos que pasan entre capas.

QUE LLEVA DENTRO EL BODY DE UNA REQUEST: NAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAA!!!!!!!!!!

Angular es un framework de desarrollo web basado en TypeScript que permite crear aplicaciones din√°micas, escalables y de alto rendimiento mediante el uso de componentes, inyecci√≥n de dependencias y un potente sistema de templates.

npm (Node Package Manager) se usa para instalar y gestionar paquetes de Node.js en un proyecto, ya sea de forma local o global.
npx (Node Package Execute) permite ejecutar paquetes sin necesidad de instalarlos, √∫til para probar herramientas o ejecutar comandos temporales sin afectar el entorno global.

Estos son 4 de los eventos mas importantes de Angular: click, input, submit y change

La diferencia principal entre un m√©todo y una funci√≥n radica en d√≥nde y c√≥mo se utilizan:
üîπ Funci√≥n ‚Üí Es un bloque de c√≥digo independiente que se puede llamar en cualquier parte del programa. No necesita estar dentro de una clase u objeto.
üîπ M√©todo ‚Üí Es una funci√≥n que est√° asociada a un objeto o una clase y se llama a trav√©s de una instancia de esa clase.
